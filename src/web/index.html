<!--Made by VSSCO on 27/11/2025 11:01 AM-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SuperMaze v1.1.0</title>

  <!-- Using Bootstrap CDN for quick UI styling (buttons, inputs, cards) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <!--
    ============================
    Embedded CSS (style block)
    ============================
    I provide extremely detailed comments here:
      - What each rule does
      - Why sizes/positions were chosen
      - Notes about theme classes
    This CSS is exactly your CSS with comments added ‚Äî no logic changed.
  -->
  <style>
    /* ============================
       Page and layout basics
       ============================ */

    /* Body: sets the app to full view height and centers content.
       - margin:0 removes default browser margin.
       - display:flex + center aligns the main UI in the middle of the window.
       - transition: background handles theme transitions smoothly. */
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background 0.3s ease;
    }

    /* ============================
       Main container styles used for the "connect" and "username" screens
       ============================ */

    /* .connect-container
       - A flex container that centers its children.
       - Used for menu-like screens (username entry, main menu). */
    .connect-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
    }

    /* .connect-card
       - Card wrapper width and visual polish (rounded corners + shadow).
       - Matches the Bootstrap aesthetic while giving a custom size. */
    .connect-card {
      width: 350px;
      border-radius: 15px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.2);
    }

    /* .connect-card .card-header
       - Gradient header for visual emphasis
       - White text for contrast
       - Rounded corners applied to top only */
    .connect-card .card-header {
      background: linear-gradient(90deg, #4facfe, #00f2fe);
      color: white;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
    }

    /* ============================
       Maze area styles
       ============================ */

    /* .maze-container
       - Fills available area (100% width/height)
       - position:relative so HUD elements (stopwatch, keystrokes) can be absolutely positioned inside it.
       - center alignment keeps the grid centered. */
    .maze-container {
      width: 100%;
      height: 100%;
      position: relative;
      background: #f5f5f5; /* light background for contrast with walls */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* .maze-grid
       - CSS Grid used to layout the maze cells.
       - Default built for 20x20, each cell 25px. The JS may override this grid-template if size changes.
       - gap:2px adds spacing between cells. */
    .maze-grid {
      display: grid;
      grid-template-columns: repeat(20, 25px);
      grid-template-rows: repeat(20, 25px);
      gap: 2px;
    }

    /* ============================
       Cell styles
       ============================ */

    /* .cell: base square for every tile in the maze.
       - border-radius:6px softens corners.
       - transition on background for small hover/visual changes. */
    .cell {
      width: 25px;
      height: 25px;
      border-radius: 6px;
      background: #fff;
      transition: background 0.1s;
    }

    /* Different cell states:
       - .wall: obstacle (dark)
       - .player: current player position (red)
       - .end: goal (limegreen)
       - .ghost: replay ghost (cyan semi-transparent) */
    .cell.wall { background: #333; }
    .cell.player { background: red; }
    .cell.end { background: limegreen; }
    .cell.ghost { background: rgba(0, 200, 255, 0.6); }

    /* ============================
       HUD: Keystrokes display
       ============================ */

    /* .keystrokes
       - Absolute positioned in the bottom-left of the maze container.
       - Displays small boxes for W A S D states. */
    .keystrokes {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      color: white;
      font-weight: bold;
      text-shadow: 0 0 5px black; /* small glow to improve readability */
    }

    /* small style for each key indicator */
    .keystrokes span {
      width: 30px;
      height: 30px;
      text-align: center;
      line-height: 30px;
      border: 1px solid #fff;
      border-radius: 6px;
      background: rgba(0,0,0,0.5);
    }

    /* ============================
       Stopwatch display
       ============================ */

    /* Positioned top-right inside the maze container for timer display. */
    .stopwatch {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 6px 12px;
      border-radius: 8px;
    }

    /* Back/Exit button placed top-left */
    .back-btn {
      position: absolute;
      top: 15px;
      left: 15px;
    }

    /* ============================
       Theme classes applied to <body>
       - The JS sets body.className = "theme-<name>" to switch themes
       - Each theme here only changes the background; you can expand to tweak other UI pieces.
       ============================ */

    /* Dark theme base colors */
    body.theme-dark {
      background: #111; /* dark page bg */
      color: #eee;      /* lighter text for contrast */
    }

    /* Pastel / gradient themes; they set background only */
    body.theme-blue { background: linear-gradient(180deg, #89f7fe, #66a6ff); }
    body.theme-green { background: linear-gradient(180deg, #a8e063, #56ab2f); }
    body.theme-pink { background: linear-gradient(180deg, #fbc2eb, #a6c1ee); }
    body.theme-red { background: linear-gradient(180deg, #ff9a9e, #f6416c); }

  </style>
</head>

<!--
  Body starts with 'theme-light' class by default.
  The JS will change this class when the user selects a different theme.
-->
<body class="theme-light">

  <!--
    ============================
    USERNAME SCREEN
    - Shown when there is no saved username
    - Contains a simple input + continue button
    - Uses Bootstrap card for layout
    ============================
  -->
  <div id="username-screen" class="connect-container">
    <div class="card connect-card text-center">
      <!-- Card header -->
      <div class="card-header"><h3>Enter Username</h3></div>

      <!-- Card body: username input + continue button -->
      <div class="card-body">
        <!-- Username input (id used in JS) -->
        <input id="username-input" type="text" class="form-control mb-3" placeholder="Your username">

        <!-- Continue button (id used in JS) -->
        <button id="continue-btn" class="btn btn-primary w-100">Continue</button>
      </div>
    </div>
  </div>

  <!--
    ============================
    MAIN MENU (CONNECT SCREEN)
    - Hidden by default (d-none)
    - Contains Start, Replay, Theme select, XP info, Leaderboard
    - When username exists, JS will hide username-screen and show this screen
    ============================
  -->
  <div id="connect-screen" class="connect-container d-none">
    <div class="card connect-card">
      <div class="card-header text-center">
        <h3>üåÄ SuperMaze</h3>
        <p class="subtitle">Version 1.1.0 - Beta</p>
      </div>
      <div class="card-body text-center">
        <!-- Start game button -->
        <button id="single-btn" class="btn btn-success w-100 mb-3">Singleplayer</button>

        <!-- Replay button (exists in UI but the JS variable is unused in some flows) -->
        <button id="replay-btn" class="btn btn-outline-primary w-100 mb-3">Replays</button>

        <!-- Theme selector: the JS listens to changes and sets body class -->
        <select id="theme-select" class="form-select mb-3">
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="pink">Pink</option>
          <option value="red">Red</option>
        </select>

        <!-- XP info (username, level, xp) filled by JS -->
        <div id="xp-info" class="mb-2 text-muted"></div>

        <!-- Leaderboard button -->
        <button id="leaderboard-btn" class="btn btn-outline-secondary w-100">Leaderboard</button>
      </div>
    </div>
  </div>

  <!--
    ============================
    MAZE SCREEN
    - Contains the grid (maze-grid) where cells are rendered by JS.
    - Keystroke HUD, stopwatch, and Exit button are placed absolutely inside this container.
    - Hidden by default (d-none).
    ============================
  -->
  <div id="maze-screen" class="maze-container d-none">
    <!-- Grid container where JS will append .cell elements -->
    <div id="maze-grid" class="maze-grid"></div>

    <!-- Keystroke visualizer (W A S D) -->
    <div id="keystrokes" class="keystrokes"></div>

    <!-- Stopwatch display -->
    <div id="stopwatch" class="stopwatch">00:00.000</div>

    <!-- Back / Exit button -->
    <button id="back-btn" class="btn btn-secondary back-btn">Exit</button>
  </div>

  <!--
    ============================
    JavaScript (embedded)
    - THIS IS YOUR ENTIRE ORIGINAL JS CODE
    - I have added very detailed comments throughout.
    - I DID NOT CHANGE any executable code ‚Äî only added comments above and inline.
    ============================
  -->
  <script>
    // === SuperMaze v1.1.0 ===
    // Full game logic including username system, maze generation, XP system,
    // stopwatch, leaderboard saving, ghost replays, key visualization, and themes.

    // -------------------------------
    // === DOM ELEMENT REFERENCES ===
    // -------------------------------

    // Screens & Containers
    const usernameScreen = document.getElementById("username-screen");   // First screen for entering username
    const usernameInput = document.getElementById("username-input");     // Text input field for username
    const continueBtn = document.getElementById("continue-btn");         // Button to submit username
    const connectScreen = document.getElementById("connect-screen");     // Main menu screen
    const mazeScreen = document.getElementById("maze-screen");           // Game screen containing maze

    // Maze + UI Elements
    const mazeGrid = document.getElementById("maze-grid");               // The grid container holding cell divs
    const themeSelect = document.getElementById("theme-select");         // Theme dropdown
    const xpInfo = document.getElementById("xp-info");                   // Shows username, level, XP
    const singleBtn = document.getElementById("single-btn");             // Start Singleplayer button
    const replayBtn = document.getElementById("replay-btn");             // (Unused) Replay button
    const leaderboardBtn = document.getElementById("leaderboard-btn");   // Opens leaderboard alert
    const backBtn = document.getElementById("back-btn");                 // Exit to menu during maze
    const keystrokesDiv = document.getElementById("keystrokes");         // Shows W A S D key states
    const stopwatchDisplay = document.getElementById("stopwatch");       // Stopwatch UI

    // -------------------------------
    // === GAME VARIABLES ===
    // -------------------------------

    // username: stored in localStorage to persist between page loads
    let username = localStorage.getItem("maze_username") || "";          // Saved username or empty until entered

    // maze: 2D array where 1 = wall, 0 = empty
    let maze = [];                                                       // 2D array representing walls & empty tiles

    // size: grid width/height. This code uses a fixed size constant (20).
    // Note: the render function and CSS are built for 20; changing size requires CSS/grid adjustments or dynamic JS sizing.
    const size = 20;                                                     // Maze grid is 20√ó20

    // player and end coordinates. They are indices into the maze 2D array.
    let player = { x: 1, y: 1 };                                         // Player starting position
    let end = { x: 18, y: 18 };                                          // End (goal) position

    // moving, gameWon: state control variables
    let moving = false;                                                  // Prevents movement spamming (unused)
    let gameWon = false;                                                 // Victory lock

    // Stopwatch related variables
    let startTime = null;                                                // Stopwatch start timestamp
    let timerInterval;                                                   // Interval ID for stopwatch updates

    // moves: stores each player position change for replay (x,y) and timestamp 't'
    let moves = [];                                                      // Stores recorded movement positions

    // replay related flags and storage
    let replayMode = false;                                              // True if ghost replay is playing
    let ghostMoves = [];                                                 // Saved ghost path

    // XP and leaderboards stored in localStorage
    let xp = parseInt(localStorage.getItem("maze_xp")) || 0;             // Total XP saved locally
    let level = Math.floor(xp / 100);                                    // Level = XP / 100 (integer)
    let leaderboard = JSON.parse(localStorage.getItem("maze_leaderboard")) || [];  // Saved runs

    // -------------------------------
    // === USERNAME SCREEN LOGIC ===
    // -------------------------------

    // If username exists, skip username screen and show main menu.
    // This makes the game remember the player between visits.
    if (username) {
      usernameScreen.classList.add("d-none");   // Hide username screen if username exists
      connectScreen.classList.remove("d-none"); // Show main menu
    } else {
      usernameScreen.classList.remove("d-none"); // Otherwise show username screen
    }

    // Handle Continue button click:
    // - Read username input
    // - Validate (non-empty)
    // - Save to localStorage
    // - Hide username screen and show main menu
    continueBtn.onclick = () => {
      const name = usernameInput.value.trim();   // Get typed username
      if (!name) return alert("Enter a username!"); // If empty, show alert and do nothing
      username = name;                           // Store username
      localStorage.setItem("maze_username", username); // Persist username
      usernameScreen.classList.add("d-none");    // Hide username screen
      connectScreen.classList.remove("d-none");  // Show main menu
      updateXPDisplay();                         // Update UI with XP/level
    };

    // -------------------------------
    // === XP SYSTEM ===
    // -------------------------------

    // Adds XP to player's total, saves it, and recalculates level.
    // This function is simple: add amount, persist, recompute level and update UI.
    function addXP(amount) {
      xp += amount;
      localStorage.setItem("maze_xp", xp);
      level = Math.floor(xp / 100);  // Level increases every 100 XP
      updateXPDisplay();             // Refresh UI to show new XP & level
    }

    // Updates the xp-info element with the player's username, level and XP.
    function updateXPDisplay() {
      xpInfo.textContent = `${username} | Level ${level} | XP: ${xp}`;
    }

    // -------------------------------
    // === MAZE GENERATION ===
    // -------------------------------

    // generateMaze:
    // - Creates a new 2D array 'maze'
    // - Fills borders with walls
    // - Places random inside walls with ~15% density
    // - Picks random empty cells for player start and goal (end)
    // Important: This generation is simple/random and does NOT guarantee solvability.
    function generateMaze() {
      maze = [];
      for (let y = 0; y < size; y++) {
        const row = [];
        for (let x = 0; x < size; x++) {
          // Walls around borders OR 15% random walls inside
          const wall = x === 0 || y === 0 ||
                       x === size - 1 || y === size - 1 ||
                       Math.random() < 0.15;
          row.push(wall ? 1 : 0);    // 1 = wall, 0 = empty
        }
        maze.push(row);
      }

      // Choose random player spawn tile
      player = randomEmptyCell();

      // Choose random end tile far enough away from player
      end = randomEmptyCell();
      while (Math.abs(player.x - end.x) + Math.abs(player.y - end.y) < 10) {
        end = randomEmptyCell();
      }

      // Ensure spawn positions are always empty (safety)
      maze[player.y][player.x] = 0;
      maze[end.y][end.x] = 0;
    }

    // randomEmptyCell:
    // - Picks random coordinates until it finds a 0 (empty) in the maze
    // - Uses optional chaining (?.) to avoid errors if maze is not yet defined
    function randomEmptyCell() {
      let x, y;
      do {
        x = Math.floor(Math.random() * size);
        y = Math.floor(Math.random() * size);
      } while (maze[y]?.[x] !== 0);  // Loop until an empty cell is found
      return { x, y };
    }

    // -------------------------------
    // === MAZE RENDERING ===
    // -------------------------------

    // renderMaze:
    // - Clears mazeGrid
    // - Sets CSS grid-template to size√ósize (25px squares)
    // - Appends div.cell for each tile and applies classes depending on tile state
    // - If ghostPos is provided, the ghost cell is drawn at that position
    function renderMaze(ghostPos = null) {
      mazeGrid.innerHTML = "";  // Clear grid before re-rendering
      mazeGrid.style.gridTemplateColumns = `repeat(${size}, 25px)`;
      mazeGrid.style.gridTemplateRows = `repeat(${size}, 25px)`;

      // Loop through all grid tiles
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");

          // Wall tiles
          if (maze[y][x] === 1) cell.classList.add("wall");

          // Player tile
          if (x === player.x && y === player.y) cell.classList.add("player");

          // Goal tile
          if (x === end.x && y === end.y) cell.classList.add("end");

          // Ghost path tile during replay
          if (ghostPos && ghostPos.x === x && ghostPos.y === y)
            cell.classList.add("ghost");

          mazeGrid.appendChild(cell);
        }
      }
    }

    // -------------------------------
    // === PLAYER MOVEMENT ===
    // -------------------------------

    // keys: holds boolean pressed states for WASD and arrow keys
    const keys = {
      w: false, a: false, s: false, d: false,
      ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false
    };

    // Key press handler:
    // - Ignores input during replayMode or after winning the game
    // - Updates keys state and UI (updateKeystrokes)
    // - Starts stopwatch if first move
    // - Computes target tile and moves player there if it's empty
    // - Records the move for replays (moves array holds x,y,t)
    document.addEventListener("keydown", (e) => {
      if (replayMode || gameWon) return;     // Disable movement if replay/victory active
      keys[e.key] = true;                    // Mark key as pressed
      updateKeystrokes();                    // Update W A S D display

      if (!startTime) startStopwatch();      // Start timer if first move

      let nx = player.x;
      let ny = player.y;

      // Movement direction logic
      if (e.key === "w" || e.key === "ArrowUp") ny--;
      if (e.key === "s" || e.key === "ArrowDown") ny++;
      if (e.key === "a" || e.key === "ArrowLeft") nx--;
      if (e.key === "d" || e.key === "ArrowRight") nx++;

      // Only move if next tile is empty (0)
      if (maze[ny]?.[nx] === 0) {
        player.x = nx;
        player.y = ny;

        // Record movement with timestamp for replay (time since start)
        moves.push({ x: nx, y: ny, t: performance.now() - startTime });

        renderMaze();        // Re-render maze with new position
        checkVictory();      // Check if reached end tile
      }
    });

    // Key release handler: clears pressed state and updates the keystroke UI
    document.addEventListener("keyup", (e) => {
      keys[e.key] = false;
      updateKeystrokes();
    });

    // -------------------------------
    // === KEYSTROKE UI ===
    // -------------------------------

    // updateKeystrokes:
    // - Renders W A S D indicators
    // - Highlights them (inline style background 'limegreen') when pressed
    function updateKeystrokes() {
      const layout = ["W", "A", "S", "D"];
      keystrokesDiv.innerHTML = "";

      layout.forEach((k) => {
        const span = document.createElement("span");
        const key = k.toLowerCase();

        span.textContent = k;     // Display key letter

        // Highlight key if pressed (also checks arrow keys variants)
        if (keys[key] || keys["Arrow" + k]) {
          span.style.background = "limegreen";
        }

        keystrokesDiv.appendChild(span);
      });
    }

    // -------------------------------
    // === STOPWATCH SYSTEM ===
    // -------------------------------

    // startStopwatch: records startTime and updates display every 30ms
    function startStopwatch() {
      startTime = performance.now();
      timerInterval = setInterval(() => {
        const time = performance.now() - startTime;
        stopwatchDisplay.textContent = formatTime(time);
      }, 30);
    }

    // stopStopwatch: clear interval to stop updates
    function stopStopwatch() {
      clearInterval(timerInterval);
    }

    // resetStopwatch: clears recording and resets the display
    function resetStopwatch() {
      startTime = null;
      stopwatchDisplay.textContent = "00:00.000";
    }

    // formatTime: converts milliseconds to "MM:SS.mmm" string
    function formatTime(ms) {
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const millis = Math.floor(ms % 1000);
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(millis).padStart(3, "0")}`;
    }

    // -------------------------------
    // === VICTORY LOGIC ===
    // -------------------------------

    // checkVictory: called after moves to see if the player reached the goal
    function checkVictory() {
      if (player.x === end.x && player.y === end.y && !gameWon) {
        gameWon = true;
        stopStopwatch();                                // Stop timer
        const totalTime = performance.now() - startTime;
        addXP(50);                                      // Reward XP
        saveRun(totalTime);                             // Save result to leaderboard
        showVictory(totalTime);                         // Show win overlay
      }
    }

    // showVictory: builds a full-screen overlay with Victory message and buttons
    function showVictory(time) {
      const overlay = document.createElement("div");
      overlay.style.position = "absolute";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.background = "rgba(0,0,0,0.8)";
      overlay.style.display = "flex";
      overlay.style.flexDirection = "column";
      overlay.style.justifyContent = "center";
      overlay.style.alignItems = "center";
      overlay.style.zIndex = "999";

      const title = document.createElement("h1");
      title.innerText = "üèÜ VICTORY!";
      title.style.color = "gold";
      title.style.fontSize = "64px";

      const timeText = document.createElement("h3");
      timeText.innerText = `Time: ${formatTime(time)}`;
      timeText.style.color = "white";

      // Replay button (play ghost run)
      const replayBtn = document.createElement("button");
      replayBtn.className = "btn btn-primary mt-3";
      replayBtn.textContent = "Replay Run";
      replayBtn.onclick = () => {
        overlay.remove();
        playReplay(leaderboard[leaderboard.length - 1].moves);
      };

      // Return to menu
      const menuBtn = document.createElement("button");
      menuBtn.className = "btn btn-secondary mt-3";
      menuBtn.textContent = "Return to Menu";
      menuBtn.onclick = () => {
        overlay.remove();
        mazeScreen.classList.add("d-none");
        connectScreen.classList.remove("d-none");
        resetGame();
      };

      overlay.append(title, timeText, replayBtn, menuBtn);
      mazeScreen.appendChild(overlay);
    }

    // -------------------------------
    // === SAVE RUN + REPLAYS ===
    // -------------------------------

    // saveRun saves run details (username, time, moves, xp, date) into leaderboard array and persist in localStorage.
    function saveRun(time) {
      const run = {
        username,
        time,
        moves,
        xp,
        date: new Date().toISOString()
      };
      leaderboard.push(run);
      localStorage.setItem("maze_leaderboard", JSON.stringify(leaderboard));
    }

    // playReplay: replays a saved run by rendering the ghost positions at ~60fps.
    // Note: this function regenerates a new maze before replaying; the ghost is rendered on top.
    function playReplay(runMoves) {
      replayMode = true;
      let i = 0;

      generateMaze();                          // New maze for replay visibility
      const ghostStart = runMoves[0];
      player = { ...ghostStart };              // Place ghost at start
      renderMaze(player);

      const interval = setInterval(() => {
        if (i >= runMoves.length) {
          clearInterval(interval);
          replayMode = false;
          resetGame();
          return;
        }
        const pos = runMoves[i];
        renderMaze(pos);                       // Render ghost at next frame
        i++;
      }, 1000 / 60);                           // 60 FPS replay
    }

    // -------------------------------
    // === START SINGLEPLAYER ===
    // -------------------------------

    // singleBtn - starts the game:
    // - resets game state
    // - generates a new maze
    // - renders it
    // - hides main menu and shows maze screen
    singleBtn.onclick = () => {
      resetGame();                             // Clear previous run data
      generateMaze();                          // Create new maze
      renderMaze();                            // Show maze
      connectScreen.classList.add("d-none");   // Hide menu
      mazeScreen.classList.remove("d-none");   // Show game screen
      resetStopwatch();                        // Reset timer
    };

    // resetGame: clears round-specific state without touching persistent data like username/xp
    function resetGame() {
      gameWon = false;
      startTime = null;
      moves = [];
      resetStopwatch();
      replayMode = false;
    }

    // -------------------------------
    // === LEADERBOARD BUTTON ===
    // -------------------------------

    // leaderboardBtn: sorts leaderboard by best time and shows an alert with top runs.
    // This is a simple UI; it can be replaced with a proper modal or screen later.
    leaderboardBtn.onclick = () => {
      let text = leaderboard
        .sort((a, b) => a.time - b.time)
        .map((r, i) => `${i + 1}. ${r.username} - ${formatTime(r.time)}`)
        .join("\n");
      alert("üèÅ Leaderboard:\n" + text);
    };

    // -------------------------------
    // === THEMES ===
    // -------------------------------

    // themeSelect: When the user picks a theme, set the body class to "theme-<value>"
    // The CSS above defines what each theme looks like (background changes).
    themeSelect.onchange = () => {
      document.body.className = "theme-" + themeSelect.value;
    };

    // -------------------------------
    // === BACK BUTTON ===
    // -------------------------------

    // backBtn: return to main menu and reset the game state.
    backBtn.onclick = () => {
      mazeScreen.classList.add("d-none");
      connectScreen.classList.remove("d-none");
      resetGame();
    };

  </script>
</body>
</html>
